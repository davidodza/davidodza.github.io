---
layout: post
published: false
categories:
  - personal
mathjax: false
featured: false
comments: true
title: Brainpan
description: ''
headline: ''
modified: ''
tags: ''
imagefeature: ''
---

This is a walk-through of CTF challenge [Brainpan: 1](https://www.vulnhub.com/entry/brainpan-1,51/). I downloaded the target VM image from vulhub and booted it in VMware. My source machine is a Kali Linux image, also running on VMware.

All my engagements start with netdiscover, which is why I scripted a smarter version I call [netDiscoverVM](https://github.com/davidodza/Pre-OSCP/blob/master/netdiscoverVM.bash). This shows the IP address of our target machine (192.168.226.128).

![netdiscover.PNG]({{site.baseurl}}/images/brainpan/netdiscover.PNG)

Then I use Sparta to run nmap and nikto scans on the target.

![sparta.PNG]({{site.baseurl}}/images/brainpan/sparta.PNG)

I connect to the target on port 9999 and it results in a "brainpan" banner and a password input screen.

![nc1.PNG]({{site.baseurl}}/images/brainpan/nc1.PNG)

I run dirb (directory buster) on port 10000 and see a /bin directory.

![dirb.PNG]({{site.baseurl}}/images/brainpan/dirb.PNG)

The /bin directory contains one EXE.

![ip slash bin.PNG]({{site.baseurl}}/images/brainpan/ip slash bin.PNG)

I download the EXE and copy it to another folder.

![cp bpan.PNG]({{site.baseurl}}/images/braipan/cp bpan.PNG)

I run strings on the EXE. It looks like the same banner from port 9999 is in this file.

![strings.PNG]({{site.baseurl}}/images/brainpan/strings.PNG)

I run the EXE locally with OllyDbg.

![olly1.PNG]({{site.baseurl}}/images/brainpan/olly1.PNG)

Using Python, I use connect() for a socket connection and send "\x41"*1000, also known as 1000 A's.

![overflow41.PNG]({{site.baseurl}}/images/brainpan/overflow41.PNG)

Taking a look at the Registers in OllyDbg after sending the A's, we notice a few things.
1. EIP is overwritten by 41414141. This is crucial because the EIP holds the "extended instruction pointer" for the stack. In other words, it tells the computer where to go next to execute the next command and controls the flow of a program.
2. EBP is overwritten by 41414141.
3. The stack is overwritten with A's starting at address 0043F7E0.

![Register41paint.PNG]({{site.baseurl}}/images/brainpan/Register41paint.PNG)

It's great that I was able to overwrite Registers and the stack with A's, however we need to pinpoint WHERE in my input string these important locations are overwritten. This is where the PWN Tools library for python comes in handy. Cyclic() will generate a string pattern of specified length. In my example, I create a 1000 character pattern, and also output a 20 character pattern to demonstrate the function.

![cyclic.PNG]({{site.baseurl}}/images/brainpan/cyclic.PNG)

After sending the 1000 char pattern to the EXE, the same resources are overwritten with more meaningful values. 

![RegisterCyclic.PNG]({{site.baseurl}}/images/brainpan/RegisterCyclic.PNG)

I use cyclic_find() to determine how many characters into the pattern EIP is overwritten. It is overwritten 524 characters into the input. The stack begins to be overwritten 528 bytes into the input string, which is directly after EIP.

![cyclicfind.PNG]({{site.baseurl}}/images/brainpan/cyclicfind.PNG)

To prove the point, I send 524 NOP's, followed by "AAAA" + "BBBB". We expect EIP to contain "AAAA" and the stack to contain "BBBB". Both hold true.

![lasttest.PNG]({{site.baseurl}}/images/brainpan/lasttest.PNG)
![RegisterVerification.PNG]({{site.baseurl}}/images/brainpan/RegisterVerification.PNG)

Now I need to find the memory location of a Jmp or Call command in the assembly of our EXE. ROPgadget is the tool for the job.

![ROPgadgetJmpCall.PNG]({{site.baseurl}}/images/brainpan/ROPgadgetJmpCall.PNG)

![packJmpESP.PNG]({{site.baseurl}}/images/brainpan/packJmpESP.PNG)

![msfvenom.PNG]({{site.baseurl}}/images/brainpan/msfvenom.PNG)

![catShell.PNG]({{site.baseurl}}/images/brainpan/catShell.PNG)

![overFlowDone.PNG]({{site.baseurl}}/images/brainpan/overFlowDone.PNG)

![firstShell.PNG]({{site.baseurl}}/images/brainpan/firstShell.PNG)

![spawn bash.PNG]({{site.baseurl}}/images/brainpan/spawn bash.PNG)

![validate.PNG]({{site.baseurl}}/images/brainpan/validate.PNG)

![testvalidate.PNG]({{site.baseurl}}/images/brainpan/testvalidate.PNG)

![base64validate.PNG]({{site.baseurl}}/images/brainpan/base64validate.PNG)

![validateonhost.PNG]({{site.baseurl}}/images/brainpan/validateonhost.PNG)

![validatehosttest.PNG]({{site.baseurl}}/images/brainpan/validatehosttest.PNG)

![gdb1.PNG]({{site.baseurl}}/images/brainpan/gdb1.PNG)

![rop2.PNG]({{site.baseurl}}/images/brainpan/rop2.PNG)

There are 116 bytes to work with before the return pointer. The shellcode is 28 bytes, therefore I will have 88 bytes of nops. I divide the nops somewhat evenly around the shellcode.

![overflow2.PNG]({{site.baseurl}}/images/brainpan/overflow2.PNG)

![overflowLocal2.PNG]({{site.baseurl}}/images/brainpan/overflowLocal2.PNG)

![root.PNG]({{site.baseurl}}/images/brainpan/root.PNG)
